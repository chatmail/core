// AUTO-GENERATED by yerpc-derive

import * as T from "./types.js"
import * as RPC from "./jsonrpc.js"

type RequestMethod = (method: string, params?: RPC.Params) => Promise<unknown>;
type NotificationMethod = (method: string, params?: RPC.Params) => void;

interface Transport {
  request: RequestMethod,
  notification: NotificationMethod
}

export class RawClient {
  constructor(private _transport: Transport) {}

  /**
   * Check if an email address is valid.
   */
  public checkEmailValidity(email: string): Promise<boolean> {
    return (this._transport.request('check_email_validity', [email] as RPC.Params)) as Promise<boolean>;
  }

  /**
   * Get general system info.
   */
  public getSystemInfo(): Promise<Record<string,string>> {
    return (this._transport.request('get_system_info', [] as RPC.Params)) as Promise<Record<string,string>>;
  }


  public addAccount(): Promise<T.U32> {
    return (this._transport.request('add_account', [] as RPC.Params)) as Promise<T.U32>;
  }


  public removeAccount(accountId: T.U32): Promise<null> {
    return (this._transport.request('remove_account', [accountId] as RPC.Params)) as Promise<null>;
  }


  public getAllAccountIds(): Promise<(T.U32)[]> {
    return (this._transport.request('get_all_account_ids', [] as RPC.Params)) as Promise<(T.U32)[]>;
  }

  /**
   * Select account id for internally selected state.
   * TODO: Likely this is deprecated as all methods take an account id now.
   */
  public selectAccount(id: T.U32): Promise<null> {
    return (this._transport.request('select_account', [id] as RPC.Params)) as Promise<null>;
  }

  /**
   * Get the selected account id of the internal state..
   * TODO: Likely this is deprecated as all methods take an account id now.
   */
  public getSelectedAccountId(): Promise<(T.U32|null)> {
    return (this._transport.request('get_selected_account_id', [] as RPC.Params)) as Promise<(T.U32|null)>;
  }

  /**
   * Get a list of all configured accounts.
   */
  public getAllAccounts(): Promise<(T.Account)[]> {
    return (this._transport.request('get_all_accounts', [] as RPC.Params)) as Promise<(T.Account)[]>;
  }

  /**
   * Get top-level info for an account.
   */
  public getAccountInfo(accountId: T.U32): Promise<T.Account> {
    return (this._transport.request('get_account_info', [accountId] as RPC.Params)) as Promise<T.Account>;
  }

  /**
   * Returns provider for the given domain.
   *
   * This function looks up domain in offline database.
   *
   * For compatibility, email address can be passed to this function
   * instead of the domain.
   */
  public getProviderInfo(accountId: T.U32, email: string): Promise<(T.ProviderInfo|null)> {
    return (this._transport.request('get_provider_info', [accountId, email] as RPC.Params)) as Promise<(T.ProviderInfo|null)>;
  }

  /**
   * Checks if the context is already configured.
   */
  public isConfigured(accountId: T.U32): Promise<boolean> {
    return (this._transport.request('is_configured', [accountId] as RPC.Params)) as Promise<boolean>;
  }

  /**
   * Get system info for an account.
   */
  public getInfo(accountId: T.U32): Promise<Record<string,string>> {
    return (this._transport.request('get_info', [accountId] as RPC.Params)) as Promise<Record<string,string>>;
  }


  public setConfig(accountId: T.U32, key: string, value: (string|null)): Promise<null> {
    return (this._transport.request('set_config', [accountId, key, value] as RPC.Params)) as Promise<null>;
  }


  public batchSetConfig(accountId: T.U32, config: Record<string,(string|null)>): Promise<null> {
    return (this._transport.request('batch_set_config', [accountId, config] as RPC.Params)) as Promise<null>;
  }

  /**
   * Set configuration values from a QR code. (technically from the URI that is stored in the qrcode)
   * Before this function is called, dc_check_qr() should confirm the type of the
   * QR code is DC_QR_ACCOUNT or DC_QR_WEBRTC_INSTANCE.
   *
   * Internally, the function will call dc_set_config() with the appropriate keys,
   * e.g. `addr` and `mail_pw` for DC_QR_ACCOUNT
   * or `webrtc_instance` for DC_QR_WEBRTC_INSTANCE.
   */
  public setConfigFromQr(accountId: T.U32, qrContent: string): Promise<null> {
    return (this._transport.request('set_config_from_qr', [accountId, qrContent] as RPC.Params)) as Promise<null>;
  }


  public checkQr(accountId: T.U32, qrContent: string): Promise<T.Qr> {
    return (this._transport.request('check_qr', [accountId, qrContent] as RPC.Params)) as Promise<T.Qr>;
  }


  public getConfig(accountId: T.U32, key: string): Promise<(string|null)> {
    return (this._transport.request('get_config', [accountId, key] as RPC.Params)) as Promise<(string|null)>;
  }


  public batchGetConfig(accountId: T.U32, keys: (string)[]): Promise<Record<string,(string|null)>> {
    return (this._transport.request('batch_get_config', [accountId, keys] as RPC.Params)) as Promise<Record<string,(string|null)>>;
  }

  /**
   * Configures this account with the currently set parameters.
   * Setup the credential config before calling this.
   */
  public configure(accountId: T.U32): Promise<null> {
    return (this._transport.request('configure', [accountId] as RPC.Params)) as Promise<null>;
  }

  /**
   * Signal an ongoing process to stop.
   */
  public stopOngoingProcess(accountId: T.U32): Promise<null> {
    return (this._transport.request('stop_ongoing_process', [accountId] as RPC.Params)) as Promise<null>;
  }

  /**
   * Returns the message IDs of all _fresh_ messages of any chat.
   * Typically used for implementing notification summaries
   * or badge counters e.g. on the app icon.
   * The list is already sorted and starts with the most recent fresh message.
   *
   * Messages belonging to muted chats or to the contact requests are not returned;
   * these messages should not be notified
   * and also badge counters should not include these messages.
   *
   * To get the number of fresh messages for a single chat, muted or not,
   * use `get_fresh_msg_cnt()`.
   */
  public getFreshMsgs(accountId: T.U32): Promise<(T.U32)[]> {
    return (this._transport.request('get_fresh_msgs', [accountId] as RPC.Params)) as Promise<(T.U32)[]>;
  }

  /**
   * Get the number of _fresh_ messages in a chat.
   * Typically used to implement a badge with a number in the chatlist.
   *
   * If the specified chat is muted,
   * the UI should show the badge counter "less obtrusive",
   * e.g. using "gray" instead of "red" color.
   */
  public getFreshMsgCnt(accountId: T.U32, chatId: T.U32): Promise<T.Usize> {
    return (this._transport.request('get_fresh_msg_cnt', [accountId, chatId] as RPC.Params)) as Promise<T.Usize>;
  }


  public autocryptInitiateKeyTransfer(accountId: T.U32): Promise<string> {
    return (this._transport.request('autocrypt_initiate_key_transfer', [accountId] as RPC.Params)) as Promise<string>;
  }


  public autocryptContinueKeyTransfer(accountId: T.U32, messageId: T.U32, setupCode: string): Promise<null> {
    return (this._transport.request('autocrypt_continue_key_transfer', [accountId, messageId, setupCode] as RPC.Params)) as Promise<null>;
  }


  public getChatlistEntries(accountId: T.U32, listFlags: (T.U32|null), queryString: (string|null), queryContactId: (T.U32|null)): Promise<(T.ChatListEntry)[]> {
    return (this._transport.request('get_chatlist_entries', [accountId, listFlags, queryString, queryContactId] as RPC.Params)) as Promise<(T.ChatListEntry)[]>;
  }


  public getChatlistItemsByEntries(accountId: T.U32, entries: (T.ChatListEntry)[]): Promise<Record<T.U32,T.ChatListItemFetchResult>> {
    return (this._transport.request('get_chatlist_items_by_entries', [accountId, entries] as RPC.Params)) as Promise<Record<T.U32,T.ChatListItemFetchResult>>;
  }


  public chatlistGetFullChatById(accountId: T.U32, chatId: T.U32): Promise<T.FullChat> {
    return (this._transport.request('chatlist_get_full_chat_by_id', [accountId, chatId] as RPC.Params)) as Promise<T.FullChat>;
  }


  public acceptChat(accountId: T.U32, chatId: T.U32): Promise<null> {
    return (this._transport.request('accept_chat', [accountId, chatId] as RPC.Params)) as Promise<null>;
  }


  public blockChat(accountId: T.U32, chatId: T.U32): Promise<null> {
    return (this._transport.request('block_chat', [accountId, chatId] as RPC.Params)) as Promise<null>;
  }


  public addDeviceMessage(accountId: T.U32, label: string, text: string): Promise<T.U32> {
    return (this._transport.request('add_device_message', [accountId, label, text] as RPC.Params)) as Promise<T.U32>;
  }


  public messageListGetMessageIds(accountId: T.U32, chatId: T.U32, flags: T.U32): Promise<(T.U32)[]> {
    return (this._transport.request('message_list_get_message_ids', [accountId, chatId, flags] as RPC.Params)) as Promise<(T.U32)[]>;
  }


  public messageGetMessage(accountId: T.U32, messageId: T.U32): Promise<T.Message> {
    return (this._transport.request('message_get_message', [accountId, messageId] as RPC.Params)) as Promise<T.Message>;
  }


  public messageGetMessages(accountId: T.U32, messageIds: (T.U32)[]): Promise<Record<T.U32,T.Message>> {
    return (this._transport.request('message_get_messages', [accountId, messageIds] as RPC.Params)) as Promise<Record<T.U32,T.Message>>;
  }

  /**
   * Get a single contact options by ID.
   */
  public contactsGetContact(accountId: T.U32, contactId: T.U32): Promise<T.Contact> {
    return (this._transport.request('contacts_get_contact', [accountId, contactId] as RPC.Params)) as Promise<T.Contact>;
  }

  /**
   * Add a single contact as a result of an explicit user action.
   *
   * Returns contact id of the created or existing contact
   */
  public contactsCreateContact(accountId: T.U32, email: string, name: (string|null)): Promise<T.U32> {
    return (this._transport.request('contacts_create_contact', [accountId, email, name] as RPC.Params)) as Promise<T.U32>;
  }

  /**
   * Returns contact id of the created or existing DM chat with that contact
   */
  public contactsCreateChatByContactId(accountId: T.U32, contactId: T.U32): Promise<T.U32> {
    return (this._transport.request('contacts_create_chat_by_contact_id', [accountId, contactId] as RPC.Params)) as Promise<T.U32>;
  }


  public contactsBlock(accountId: T.U32, contactId: T.U32): Promise<null> {
    return (this._transport.request('contacts_block', [accountId, contactId] as RPC.Params)) as Promise<null>;
  }


  public contactsUnblock(accountId: T.U32, contactId: T.U32): Promise<null> {
    return (this._transport.request('contacts_unblock', [accountId, contactId] as RPC.Params)) as Promise<null>;
  }


  public contactsGetBlocked(accountId: T.U32): Promise<(T.Contact)[]> {
    return (this._transport.request('contacts_get_blocked', [accountId] as RPC.Params)) as Promise<(T.Contact)[]>;
  }


  public contactsGetContactIds(accountId: T.U32, listFlags: T.U32, query: (string|null)): Promise<(T.U32)[]> {
    return (this._transport.request('contacts_get_contact_ids', [accountId, listFlags, query] as RPC.Params)) as Promise<(T.U32)[]>;
  }

  /**
   * Get a list of contacts.
   * (formerly called getContacts2 in desktop)
   */
  public contactsGetContacts(accountId: T.U32, listFlags: T.U32, query: (string|null)): Promise<(T.Contact)[]> {
    return (this._transport.request('contacts_get_contacts', [accountId, listFlags, query] as RPC.Params)) as Promise<(T.Contact)[]>;
  }


  public contactsGetContactsByIds(accountId: T.U32, ids: (T.U32)[]): Promise<Record<T.U32,T.Contact>> {
    return (this._transport.request('contacts_get_contacts_by_ids', [accountId, ids] as RPC.Params)) as Promise<Record<T.U32,T.Contact>>;
  }

  /**
   * Returns all message IDs of the given types in a chat.
   * Typically used to show a gallery.
   *
   * The list is already sorted and starts with the oldest message.
   * Clients should not try to re-sort the list as this would be an expensive action
   * and would result in inconsistencies between clients.
   *
   * Setting `chat_id` to `None` (`null` in typescript) means get messages with media
   * from any chat of the currently used account.
   */
  public chatGetMedia(accountId: T.U32, chatId: (T.U32|null), messageType: T.Viewtype, orMessageType2: (T.Viewtype|null), orMessageType3: (T.Viewtype|null)): Promise<(T.U32)[]> {
    return (this._transport.request('chat_get_media', [accountId, chatId, messageType, orMessageType2, orMessageType3] as RPC.Params)) as Promise<(T.U32)[]>;
  }


  public webxdcSendStatusUpdate(accountId: T.U32, instanceMsgId: T.U32, updateStr: string, description: string): Promise<null> {
    return (this._transport.request('webxdc_send_status_update', [accountId, instanceMsgId, updateStr, description] as RPC.Params)) as Promise<null>;
  }


  public webxdcGetStatusUpdates(accountId: T.U32, instanceMsgId: T.U32, lastKnownSerial: T.U32): Promise<string> {
    return (this._transport.request('webxdc_get_status_updates', [accountId, instanceMsgId, lastKnownSerial] as RPC.Params)) as Promise<string>;
  }

  /**
   * Get info from a webxdc message
   */
  public messageGetWebxdcInfo(accountId: T.U32, instanceMsgId: T.U32): Promise<T.WebxdcMessageInfo> {
    return (this._transport.request('message_get_webxdc_info', [accountId, instanceMsgId] as RPC.Params)) as Promise<T.WebxdcMessageInfo>;
  }

  /**
   * Returns the messageid of the sent message
   */
  public miscSendTextMessage(accountId: T.U32, text: string, chatId: T.U32): Promise<T.U32> {
    return (this._transport.request('misc_send_text_message', [accountId, text, chatId] as RPC.Params)) as Promise<T.U32>;
  }


}
