// AUTO-GENERATED by yerpc-derive

import * as T from "./types.js"
import * as RPC from "./jsonrpc.js"

type RequestMethod = (method: string, params?: RPC.Params) => Promise<unknown>;
type NotificationMethod = (method: string, params?: RPC.Params) => void;

interface Transport {
  request: RequestMethod,
  notification: NotificationMethod
}

export class RawClient {
  constructor(private _transport: Transport) {}

  /**
   * Check if an email address is valid.
   */
  public checkEmailValidity(email: string): Promise<boolean> {
    return (this._transport.request('check_email_validity', [email] as RPC.Params)) as Promise<boolean>;
  }

  /**
   * Get general system info.
   */
  public getSystemInfo(): Promise<Record<string,string>> {
    return (this._transport.request('get_system_info', [] as RPC.Params)) as Promise<Record<string,string>>;
  }


  public addAccount(): Promise<T.U32> {
    return (this._transport.request('add_account', [] as RPC.Params)) as Promise<T.U32>;
  }


  public removeAccount(accountId: T.U32): Promise<null> {
    return (this._transport.request('remove_account', [accountId] as RPC.Params)) as Promise<null>;
  }


  public getAllAccountIds(): Promise<(T.U32)[]> {
    return (this._transport.request('get_all_account_ids', [] as RPC.Params)) as Promise<(T.U32)[]>;
  }

  /**
   * Select account id for internally selected state.
   * TODO: Likely this is deprecated as all methods take an account id now.
   */
  public selectAccount(id: T.U32): Promise<null> {
    return (this._transport.request('select_account', [id] as RPC.Params)) as Promise<null>;
  }

  /**
   * Get the selected account id of the internal state..
   * TODO: Likely this is deprecated as all methods take an account id now.
   */
  public getSelectedAccountId(): Promise<(T.U32|null)> {
    return (this._transport.request('get_selected_account_id', [] as RPC.Params)) as Promise<(T.U32|null)>;
  }

  /**
   * Get a list of all configured accounts.
   */
  public getAllAccounts(): Promise<(T.Account)[]> {
    return (this._transport.request('get_all_accounts', [] as RPC.Params)) as Promise<(T.Account)[]>;
  }

  /**
   * Get top-level info for an account.
   */
  public getAccountInfo(accountId: T.U32): Promise<T.Account> {
    return (this._transport.request('get_account_info', [accountId] as RPC.Params)) as Promise<T.Account>;
  }

  /**
   * Returns provider for the given domain.
   *
   * This function looks up domain in offline database.
   *
   * For compatibility, email address can be passed to this function
   * instead of the domain.
   */
  public getProviderInfo(accountId: T.U32, email: string): Promise<(T.ProviderInfo|null)> {
    return (this._transport.request('get_provider_info', [accountId, email] as RPC.Params)) as Promise<(T.ProviderInfo|null)>;
  }

  /**
   * Checks if the context is already configured.
   */
  public isConfigured(accountId: T.U32): Promise<boolean> {
    return (this._transport.request('is_configured', [accountId] as RPC.Params)) as Promise<boolean>;
  }

  /**
   * Get system info for an account.
   */
  public getInfo(accountId: T.U32): Promise<Record<string,string>> {
    return (this._transport.request('get_info', [accountId] as RPC.Params)) as Promise<Record<string,string>>;
  }


  public setConfig(accountId: T.U32, key: string, value: (string|null)): Promise<null> {
    return (this._transport.request('set_config', [accountId, key, value] as RPC.Params)) as Promise<null>;
  }


  public batchSetConfig(accountId: T.U32, config: Record<string,(string|null)>): Promise<null> {
    return (this._transport.request('batch_set_config', [accountId, config] as RPC.Params)) as Promise<null>;
  }

  /**
   * Set configuration values from a QR code. (technically from the URI that is stored in the qrcode)
   * Before this function is called, `checkQr()` should confirm the type of the
   * QR code is `account` or `webrtcInstance`.
   *
   * Internally, the function will call dc_set_config() with the appropriate keys,
   */
  public setConfigFromQr(accountId: T.U32, qrContent: string): Promise<null> {
    return (this._transport.request('set_config_from_qr', [accountId, qrContent] as RPC.Params)) as Promise<null>;
  }


  public checkQr(accountId: T.U32, qrContent: string): Promise<T.Qr> {
    return (this._transport.request('check_qr', [accountId, qrContent] as RPC.Params)) as Promise<T.Qr>;
  }


  public getConfig(accountId: T.U32, key: string): Promise<(string|null)> {
    return (this._transport.request('get_config', [accountId, key] as RPC.Params)) as Promise<(string|null)>;
  }


  public batchGetConfig(accountId: T.U32, keys: (string)[]): Promise<Record<string,(string|null)>> {
    return (this._transport.request('batch_get_config', [accountId, keys] as RPC.Params)) as Promise<Record<string,(string|null)>>;
  }

  /**
   * Configures this account with the currently set parameters.
   * Setup the credential config before calling this.
   */
  public configure(accountId: T.U32): Promise<null> {
    return (this._transport.request('configure', [accountId] as RPC.Params)) as Promise<null>;
  }

  /**
   * Signal an ongoing process to stop.
   */
  public stopOngoingProcess(accountId: T.U32): Promise<null> {
    return (this._transport.request('stop_ongoing_process', [accountId] as RPC.Params)) as Promise<null>;
  }

  /**
   * Returns the message IDs of all _fresh_ messages of any chat.
   * Typically used for implementing notification summaries
   * or badge counters e.g. on the app icon.
   * The list is already sorted and starts with the most recent fresh message.
   *
   * Messages belonging to muted chats or to the contact requests are not returned;
   * these messages should not be notified
   * and also badge counters should not include these messages.
   *
   * To get the number of fresh messages for a single chat, muted or not,
   * use `get_fresh_msg_cnt()`.
   */
  public getFreshMsgs(accountId: T.U32): Promise<(T.U32)[]> {
    return (this._transport.request('get_fresh_msgs', [accountId] as RPC.Params)) as Promise<(T.U32)[]>;
  }

  /**
   * Get the number of _fresh_ messages in a chat.
   * Typically used to implement a badge with a number in the chatlist.
   *
   * If the specified chat is muted,
   * the UI should show the badge counter "less obtrusive",
   * e.g. using "gray" instead of "red" color.
   */
  public getFreshMsgCnt(accountId: T.U32, chatId: T.U32): Promise<T.Usize> {
    return (this._transport.request('get_fresh_msg_cnt', [accountId, chatId] as RPC.Params)) as Promise<T.Usize>;
  }


  public autocryptInitiateKeyTransfer(accountId: T.U32): Promise<string> {
    return (this._transport.request('autocrypt_initiate_key_transfer', [accountId] as RPC.Params)) as Promise<string>;
  }


  public autocryptContinueKeyTransfer(accountId: T.U32, messageId: T.U32, setupCode: string): Promise<null> {
    return (this._transport.request('autocrypt_continue_key_transfer', [accountId, messageId, setupCode] as RPC.Params)) as Promise<null>;
  }


  public getChatlistEntries(accountId: T.U32, listFlags: (T.U32|null), queryString: (string|null), queryContactId: (T.U32|null)): Promise<(T.ChatListEntry)[]> {
    return (this._transport.request('get_chatlist_entries', [accountId, listFlags, queryString, queryContactId] as RPC.Params)) as Promise<(T.ChatListEntry)[]>;
  }


  public getChatlistItemsByEntries(accountId: T.U32, entries: (T.ChatListEntry)[]): Promise<Record<T.U32,T.ChatListItemFetchResult>> {
    return (this._transport.request('get_chatlist_items_by_entries', [accountId, entries] as RPC.Params)) as Promise<Record<T.U32,T.ChatListItemFetchResult>>;
  }


  public chatlistGetFullChatById(accountId: T.U32, chatId: T.U32): Promise<T.FullChat> {
    return (this._transport.request('chatlist_get_full_chat_by_id', [accountId, chatId] as RPC.Params)) as Promise<T.FullChat>;
  }


  public acceptChat(accountId: T.U32, chatId: T.U32): Promise<null> {
    return (this._transport.request('accept_chat', [accountId, chatId] as RPC.Params)) as Promise<null>;
  }


  public blockChat(accountId: T.U32, chatId: T.U32): Promise<null> {
    return (this._transport.request('block_chat', [accountId, chatId] as RPC.Params)) as Promise<null>;
  }

  /**
   * Delete a chat.
   *
   * Messages are deleted from the device and the chat database entry is deleted.
   * After that, the event #DC_EVENT_MSGS_CHANGED is posted.
   *
   * Things that are _not done_ implicitly:
   *
   * - Messages are **not deleted from the server**.
   * - The chat or the contact is **not blocked**, so new messages from the user/the group may appear as a contact request
   *   and the user may create the chat again.
   * - **Groups are not left** - this would
   *   be unexpected as (1) deleting a normal chat also does not prevent new mails
   *   from arriving, (2) leaving a group requires sending a message to
   *   all group members - especially for groups not used for a longer time, this is
   *   really unexpected when deletion results in contacting all members again,
   *   (3) only leaving groups is also a valid usecase.
   *
   * To leave a chat explicitly, use dc_remove_contact_from_chat() with
   * chat_id=DC_CONTACT_ID_SELF)
   */
  public deleteChat(accountId: T.U32, chatId: T.U32): Promise<null> {
    return (this._transport.request('delete_chat', [accountId, chatId] as RPC.Params)) as Promise<null>;
  }

  /**
   * Get encryption info for a chat.
   * Get a multi-line encryption info, containing encryption preferences of all members.
   * Can be used to find out why messages sent to group are not encrypted.
   *
   * returns Multi-line text
   */
  public getChatEncryptionInfo(accountId: T.U32, chatId: T.U32): Promise<string> {
    return (this._transport.request('get_chat_encryption_info', [accountId, chatId] as RPC.Params)) as Promise<string>;
  }

  /**
   * Get QR code (text and SVG) that will offer an Setup-Contact or Verified-Group invitation.
   * The QR code is compatible to the OPENPGP4FPR format
   * so that a basic fingerprint comparison also works e.g. with OpenKeychain.
   *
   * The scanning device will pass the scanned content to `checkQr()` then;
   * if `checkQr()` returns `askVerifyContact` or `askVerifyGroup`
   * an out-of-band-verification can be joined using dc_join_securejoin()
   *
   * chat_id: If set to a group-chat-id,
   *     the Verified-Group-Invite protocol is offered in the QR code;
   *     works for protected groups as well as for normal groups.
   *     If not set, the Setup-Contact protocol is offered in the QR code.
   *     See https://countermitm.readthedocs.io/en/latest/new.html
   *     for details about both protocols.
   */
  public getChatSecurejoinQrCodeSvg(accountId: T.U32, chatId: (T.U32|null)): Promise<[string,string]> {
    return (this._transport.request('get_chat_securejoin_qr_code_svg', [accountId, chatId] as RPC.Params)) as Promise<[string,string]>;
  }


  public leaveGroup(accountId: T.U32, chatId: T.U32): Promise<null> {
    return (this._transport.request('leave_group', [accountId, chatId] as RPC.Params)) as Promise<null>;
  }

  /**
   * Remove a member from a group.
   *
   * If the group is already _promoted_ (any message was sent to the group),
   * all group members are informed by a special status message that is sent automatically by this function.
   *
   * Sends out #DC_EVENT_CHAT_MODIFIED and #DC_EVENT_MSGS_CHANGED if a status message was sent.
   */
  public removeContactFromChat(accountId: T.U32, chatId: T.U32, contactId: T.U32): Promise<null> {
    return (this._transport.request('remove_contact_from_chat', [accountId, chatId, contactId] as RPC.Params)) as Promise<null>;
  }

  /**
   * Add a member to a group.
   *
   * If the group is already _promoted_ (any message was sent to the group),
   * all group members are informed by a special status message that is sent automatically by this function.
   *
   * If the group has group protection enabled, only verified contacts can be added to the group.
   *
   * Sends out #DC_EVENT_CHAT_MODIFIED and #DC_EVENT_MSGS_CHANGED if a status message was sent.
   */
  public addContactToChat(accountId: T.U32, chatId: T.U32, contactId: T.U32): Promise<null> {
    return (this._transport.request('add_contact_to_chat', [accountId, chatId, contactId] as RPC.Params)) as Promise<null>;
  }


  public addDeviceMessage(accountId: T.U32, label: string, text: string): Promise<T.U32> {
    return (this._transport.request('add_device_message', [accountId, label, text] as RPC.Params)) as Promise<T.U32>;
  }


  public messageListGetMessageIds(accountId: T.U32, chatId: T.U32, flags: T.U32): Promise<(T.U32)[]> {
    return (this._transport.request('message_list_get_message_ids', [accountId, chatId, flags] as RPC.Params)) as Promise<(T.U32)[]>;
  }


  public messageGetMessage(accountId: T.U32, messageId: T.U32): Promise<T.Message> {
    return (this._transport.request('message_get_message', [accountId, messageId] as RPC.Params)) as Promise<T.Message>;
  }


  public messageGetMessages(accountId: T.U32, messageIds: (T.U32)[]): Promise<Record<T.U32,T.Message>> {
    return (this._transport.request('message_get_messages', [accountId, messageIds] as RPC.Params)) as Promise<Record<T.U32,T.Message>>;
  }

  /**
   * Delete messages. The messages are deleted on the current device and
   * on the IMAP server.
   */
  public deleteMessages(accountId: T.U32, messageIds: (T.U32)[]): Promise<null> {
    return (this._transport.request('delete_messages', [accountId, messageIds] as RPC.Params)) as Promise<null>;
  }

  /**
   * Get an informational text for a single message. The text is multiline and may
   * contain e.g. the raw text of the message.
   *
   * The max. text returned is typically longer (about 100000 characters) than the
   * max. text returned by dc_msg_get_text() (about 30000 characters).
   */
  public getMessageInfo(accountId: T.U32, messageId: T.U32): Promise<string> {
    return (this._transport.request('get_message_info', [accountId, messageId] as RPC.Params)) as Promise<string>;
  }

  /**
   * Get a single contact options by ID.
   */
  public contactsGetContact(accountId: T.U32, contactId: T.U32): Promise<T.Contact> {
    return (this._transport.request('contacts_get_contact', [accountId, contactId] as RPC.Params)) as Promise<T.Contact>;
  }

  /**
   * Add a single contact as a result of an explicit user action.
   *
   * Returns contact id of the created or existing contact
   */
  public contactsCreateContact(accountId: T.U32, email: string, name: (string|null)): Promise<T.U32> {
    return (this._transport.request('contacts_create_contact', [accountId, email, name] as RPC.Params)) as Promise<T.U32>;
  }

  /**
   * Returns contact id of the created or existing DM chat with that contact
   */
  public contactsCreateChatByContactId(accountId: T.U32, contactId: T.U32): Promise<T.U32> {
    return (this._transport.request('contacts_create_chat_by_contact_id', [accountId, contactId] as RPC.Params)) as Promise<T.U32>;
  }


  public contactsBlock(accountId: T.U32, contactId: T.U32): Promise<null> {
    return (this._transport.request('contacts_block', [accountId, contactId] as RPC.Params)) as Promise<null>;
  }


  public contactsUnblock(accountId: T.U32, contactId: T.U32): Promise<null> {
    return (this._transport.request('contacts_unblock', [accountId, contactId] as RPC.Params)) as Promise<null>;
  }


  public contactsGetBlocked(accountId: T.U32): Promise<(T.Contact)[]> {
    return (this._transport.request('contacts_get_blocked', [accountId] as RPC.Params)) as Promise<(T.Contact)[]>;
  }


  public contactsGetContactIds(accountId: T.U32, listFlags: T.U32, query: (string|null)): Promise<(T.U32)[]> {
    return (this._transport.request('contacts_get_contact_ids', [accountId, listFlags, query] as RPC.Params)) as Promise<(T.U32)[]>;
  }

  /**
   * Get a list of contacts.
   * (formerly called getContacts2 in desktop)
   */
  public contactsGetContacts(accountId: T.U32, listFlags: T.U32, query: (string|null)): Promise<(T.Contact)[]> {
    return (this._transport.request('contacts_get_contacts', [accountId, listFlags, query] as RPC.Params)) as Promise<(T.Contact)[]>;
  }


  public contactsGetContactsByIds(accountId: T.U32, ids: (T.U32)[]): Promise<Record<T.U32,T.Contact>> {
    return (this._transport.request('contacts_get_contacts_by_ids', [accountId, ids] as RPC.Params)) as Promise<Record<T.U32,T.Contact>>;
  }

  /**
   * Returns all message IDs of the given types in a chat.
   * Typically used to show a gallery.
   *
   * The list is already sorted and starts with the oldest message.
   * Clients should not try to re-sort the list as this would be an expensive action
   * and would result in inconsistencies between clients.
   *
   * Setting `chat_id` to `None` (`null` in typescript) means get messages with media
   * from any chat of the currently used account.
   */
  public chatGetMedia(accountId: T.U32, chatId: (T.U32|null), messageType: T.Viewtype, orMessageType2: (T.Viewtype|null), orMessageType3: (T.Viewtype|null)): Promise<(T.U32)[]> {
    return (this._transport.request('chat_get_media', [accountId, chatId, messageType, orMessageType2, orMessageType3] as RPC.Params)) as Promise<(T.U32)[]>;
  }


  public webxdcSendStatusUpdate(accountId: T.U32, instanceMsgId: T.U32, updateStr: string, description: string): Promise<null> {
    return (this._transport.request('webxdc_send_status_update', [accountId, instanceMsgId, updateStr, description] as RPC.Params)) as Promise<null>;
  }


  public webxdcGetStatusUpdates(accountId: T.U32, instanceMsgId: T.U32, lastKnownSerial: T.U32): Promise<string> {
    return (this._transport.request('webxdc_get_status_updates', [accountId, instanceMsgId, lastKnownSerial] as RPC.Params)) as Promise<string>;
  }

  /**
   * Get info from a webxdc message
   */
  public messageGetWebxdcInfo(accountId: T.U32, instanceMsgId: T.U32): Promise<T.WebxdcMessageInfo> {
    return (this._transport.request('message_get_webxdc_info', [accountId, instanceMsgId] as RPC.Params)) as Promise<T.WebxdcMessageInfo>;
  }

  /**
   * Returns the messageid of the sent message
   */
  public miscSendTextMessage(accountId: T.U32, text: string, chatId: T.U32): Promise<T.U32> {
    return (this._transport.request('misc_send_text_message', [accountId, text, chatId] as RPC.Params)) as Promise<T.U32>;
  }


}
